---
title: "Oracle PL/SQL Bulk Operations: FORALL ve BULK COLLECT ile Performans"
description: "Oracle PL/SQL'de binlerce satırı işlerken döngü kullanmak yerine FORALL ve BULK COLLECT kullanarak performansı nasıl artırabileceğinizi öğrenin."
date: "2026-01-16"
category: "Performans"
tags: ["Oracle PL/SQL", "Bulk Collect", "FORALL", "Performance Tuning", "Database Development", "Context Switching"]
author: "Oracle DBA Blog"
---

# Oracle PL/SQL Bulk Operations: FORALL ve BULK COLLECT

PL/SQL dünyasında performansın en büyük düşmanı **Context Switching**'dir (Bağlam Değiştirme). PL/SQL motoru (mantıksal işlemler) ile SQL motoru (veri işlemleri) arasındaki her bir geçiş, milisaniyelik gecikmelere neden olur. Geleneksel bir `FOR` döngüsünde her satır için bu geçiş yapılırsa, milyonlarca satırda bu gecikme saatlere dönüşebilir. **Bulking** teknikleri (`BULK COLLECT` ve `FORALL`), verileri tek tek değil, topluca (batch) motorlar arasında taşıyarak bu gecikmeyi minimize eder.


<!--truncate-->
## 1. Context Switching Sorunu

Geleneksel yöntem (Yavaş):
```sql
-- Her bir INSERT/UPDATE işlemi için PL/SQL'den SQL motoruna geçiş yapılır.
FOR rec IN (SELECT * FROM huge_table) LOOP
   UPDATE target_table SET value = rec.value WHERE id = rec.id;
END LOOP;
```

---

## 2. BULK COLLECT: Veriyi Belleğe Topluca Çekme

`BULK COLLECT` ifadesi, bir sorgunun sonucunu satır satır değil, bir "Collection" içine topluca çekmemizi sağlar.

```sql
DECLARE
  TYPE t_id IS TABLE OF employees.employee_id%TYPE;
  v_ids t_id;
BEGIN
  SELECT employee_id 
  BULK COLLECT INTO v_ids 
  FROM employees 
  WHERE department_id = 90;

  DBMS_OUTPUT.PUT_LINE(v_ids.COUNT || ' satır topluca çekildi.');
END;
/
```

---

## 3. FORALL: Veriyi Topluca İşleme

`FORALL`, PL/SQL koleksiyonundaki tüm verileri tek bir seferde SQL motoruna göndererek DML (INSERT, UPDATE, DELETE) işlemlerini gerçekleştirir.

```sql
DECLARE
  TYPE t_rec IS TABLE OF target_table%ROWTYPE INDEX BY PLS_INTEGER;
  v_data t_rec;
BEGIN
  -- 1. Veriyi çek (Limit kullanarak belleği koru)
  SELECT * BULK COLLECT INTO v_data 
  FROM source_table 
  WHERE status = 'NEW'
  LIMIT 5000;

  -- 2. Topluca güncelle (FORALL döngü değildir, tek bir komut gibi çalışır)
  FORALL i IN 1..v_data.COUNT
    UPDATE target_table 
    SET status = 'PROCESSED' 
    WHERE id = v_data(i).id;

  COMMIT;
END;
/
```

---

## 4. Hata Yönetimi (SAVE EXCEPTIONS)

Bulk işlemler sırasında bir satırda hata oluşursa tüm işlem iptal olabilir. Bunu önlemek ve hatalı satırları raporlamak için `SAVE EXCEPTIONS` kullanılır:

```sql
BEGIN
  FORALL i IN 1..v_data.COUNT SAVE EXCEPTIONS
    INSERT INTO target_table VALUES v_data(i);
EXCEPTION
  WHEN OTHERS THEN
    FOR i IN 1..SQL%BULK_EXCEPTIONS.COUNT LOOP
      DBMS_OUTPUT.PUT_LINE('Hata Index: ' || SQL%BULK_EXCEPTIONS(i).ERROR_INDEX || 
                          ' Hata Kodu: ' || SQL%BULK_EXCEPTIONS(i).ERROR_CODE);
    END LOOP;
END;
/
```

## Performans Karşılaştırması ve İpuçları

-   **Hız Farkı:** Bulk işlemler, geleneksel satır bazlı döngülere göre **10 ila 100 kat** daha hızlı sonuç verebilir.
-   **Limit Kullanımı:** `BULK COLLECT` yaparken `LIMIT` ifadesini (örn: 1000 veya 5000) kullanmak çok önemlidir. Sınırsız veri çekmek `PGA` belleğinin dolmasına ve sunucunun kilitlenmesine neden olabilir.
-   **Trigger Kontrolü:** Bulk update veya insert yapmadan önce, hedef tablo üzerindeki ağır row-level trigger'ları geçici olarak devre dışı bırakmak performansı zirveye taşır.

Bulk operations, PL/SQL geliştiricileri için "olmazsa olmaz" bir optimizasyon aracıdır. Büyük veri setleriyle uğraşırken veritabanınızı yormak yerine bu tekniklerle akıllıca kod yazın.
